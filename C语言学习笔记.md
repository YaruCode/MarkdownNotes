# C语言学习笔记
## C语言中的关键字
|关键字|说明|
|---|---|
|auto|声明自动变量|
|case|开关语句分支|
|extern|声明变量或函数在其他文本或本文件的其他位置定义|
|register|声明寄存器变量|
|signed|声明有符号类型的变量或者函数|
|typedef|用于给数据类型取别名|
|unsigned|用于声明无符号类型变量或者函数|
|union|声明共用体类型|
|volatile|说明变量在程序中可被隐含的改变|

## C语言中的数据类型
|序号|类型|描述|
|-|-|-|
|1|基本类型|算术类型，包括整型和浮点型|
|2|枚举类型|也是算术类型，用来定义在程序中只能赋予它一定的整数离散值的变量|
|3|void类型|类型说明符void，表示没有可用的值|
|4|派生类型|指针类型，数组类型，结构类型，共用体类型和函数类型|
********************
<font size=3 color=blue>
数组类型和结构类型统称为聚合类型。函数的类型指的是函数的返回值类型，
</font>



##### sizeof(type)函数的使用
可以使用sizeof(type)函数来得到某个类型的大小
```c
#include<stdio.h>
int main()
{

    printf("int 存储大小:%lu\n",sizeof(int));
    return 0;
}
```

###### C语言中定义常量
* 使用#define预处理指令
```c
#define shanghai 100
```
* 使用const关键字
```c
const type variable =value
```
<font size=3 color=blue>
把常量定义为大写字母形式，是一个很好的编程习惯。
</font>



##### 存储类
存储类定义C程序中变量/函数的范围(可见性)和声明周期。这些说明符号放在他们所修饰的类型之前，C语言中可以用的存储类有：
* auto
* register
* static
* extern

###### auto存储类
auto存储类是所有局部变量的默认存储类
```c
int  mount;
auto int month; 
```
上面定义了两个带有相同的存储类的变量，auto只能用在函数内，即auto只能修饰局部变量

###### register存储类
register存储类用于定义存储在寄存器中而不是RAM中的局部变量，这意味着变量的最大尺寸等于寄存器的大小(通常是一个word),且不对它应用'&'运算符(因为它没有可用的内存位置)
```c
register int miles;

```
寄存器只用于需要快速访问的变量，比如计数器。
需要的注意的是：定义register变量并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。

###### static 存储类
static 存储类指示编译器在程序的，而不需要在每次进入作用域时进行创建和销毁。因此，因此使用static修饰局部变量可以在函数调用之间保持局部变量的值
```c
#include<stdio.h>
static int Max=100;
int main()
{

	printf("origin vbalue:%d\n",Max);
	Add();
	printf("After add value:%d\n",Max);
	Sub();
	Sub();
	printf("After sub value:%d\n",Max);
	return 0;	
}
void Add()
{
	Max++;
}
void Sub()
{
	Max--;
}
```

###### extern存储类
extern存储类用于提供一个全局变量的引用类，全局变量对所有文件都是可见的
**extern修饰符通常用于当有两个或多个文件共享相同的啊全局变量或函数的时候**

## C语言中的运算符
* 算术运算符
* 关系运算符
* 逻辑运算符
* 位运算符
* 赋值运算符
* 杂项运算符

前面的几个运算符比较好理解，这里只是记录一下杂项运算符：
|运算符|描述|实例|
|-|-|-|
|sizeof(type)|返回变量的大小|sizeof(a)|
|&|返回变量的地址|&a;返回变量a的地址|
|*|指向一个变量|* a;将指向一个变量|
|？:|三目表达式|无|

## C语言中的函数
函数的声明：函数声明告诉编译器函数的名称，返回类型和参数。函数定义提供了函数的实际主体

###### 调用函数时有两种向函数传递参数的方式：
|调用类型|藐视|
|-|-|
|传值调用|该方式会把参数的实际值复制给函数的形式参数，这中方式修改函数的形式参数不会改变实际参数的值|
|引用调用|通过指针传递方式，形式参数为指向实际地址的指针，当对形参的指向做操作时，就相当于对实际参数的本身进行操作|


###### 全局变量与局部变量在内存中的区别：
* 全局变量保存在内存的全局区域中，占用静态的存储单元
* 局部变量保存在栈中，只有在局部变量所在的函数被调用时才会动态的被分配存储单元

###### 数组作为函数的参数传递
* 形式参数是一个指针
```c
void Myfunc(int *param)
```
* 形式参数是一个未定义大小的数组
```c
  void Myfunc(int param[])
```
* 形式参数是一个已定义大小的数组
```c
void Myfunc(int param[10])
```



## C语言中的指针

```c
 	int test=10;
 	int * p_test;
 	p_test=&test;
 	printf("addr of test:%p\n",p_test);
```
* p_test是一个指针，存储了变量test的地址
* 指针p_test的类型必须与变量test的类型一样，因为整型的指针只能存储整型变量的指针地址
##### 什么是指针：
指针就是内存地址，指针变量是用来保存保存内存地址的变量。跟普通的变量一样，指针变量在使用之前也需要事先声明
```c
type * var-name
```
###### C中的NULL指针
在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋予一个NULL值，赋予为NULL值的指针被称为空指针，NULL指针是一个定义在便准库中的值为零的指针

##### C语言中的指针详解：
* 指针的算术运算
指针是一个用数值表示的地址，所以可以对指针进行四种算术运算：+，-，++，--
结社ptr是一个指向地址1000的整型指针，是一个32位的整数，那么ptr++会指向1004，因为整型是四个字节的
1. 指针加一会指向下一个存储单元
2. 指针减一会指向前一个存储单元
3. 指针在加减时跳跃的字节数取决于指针的类型的长度

* 指针数组
* 指向指针的指针
* 传递指针给函数
  
* 从函数返回指针








