
# 读者-写者问题
问题描述：有读者和写者两组并发进程，共享一个文件，当两个或以上的读者进程同时访问共享数据时不会产生副作用,但若某个写进程和其他进程(读者或写者)同时访问共享数据时可能会导致数据不一致的问题。因此要求：
1. 允许多个读者进程可以同时对文件执行读操作
2. 只允许一个写者往文件中些信息
3. 任一写者在完成操作之前不允许其他读者或写者工作
4. 写者执行操作之前，应让已有的读者和写者全部退出

<font size=3 color=blue>问题分析</font>
* 关系分析。由题目分析读者和写者进程时互斥打的，写者和写者也是互斥的，而读者和读者不存在互斥问题
* 整理思路。两个进程，即读者和写者。写者是比较简单的，它和任何进程都是互斥的，用互斥信号量得到P操作和V操作即可解决问题。读者的问题比较复杂，它必须实现与写者的互斥同时，实现与其它读者的同步，因此简单的一对P操作、V操作是无法解决问题的。这里用到了一个计数器，用它来判断当前是否有读者读文件。当有读者时，写者进程是无法写文件的，此时读者会一直占用文件，当没有读者时，写者才可以写文件。**同时，这里对计数器的访问也应该时互斥的**
* 信号量设置。首先设置一个信号量count计数器，用于记录当前读者的数量，初始值为0。设置mutex为互斥信号量，用于保护更新count变量时的互斥；设置互斥信号量rw，用于保证读者和写者的互斥访问。
```C++
int count=0;//用于记录当前的读者数量
semaphore mutex=1;//用于保护更新当前count变量时的互斥
semaphore rw=1;//用户保证读者和写者互斥的访问文件

writer()
{
    while(1)
    {
        P(rw);//互斥访问共享文件
        writing();//写入
        V(rw);//释放共享文件
    }
}
reader()
{
    while(1)
    {
        P(mutex);//互斥的访问count变量
        if(count==0)//当第一个读者进程读共享文件时
        {
            P(rw);//阻止写者
        }
        count++;//读者进程数加1
        V(mutex);//释放互斥变量count
        reading();//读取
        P(mutex);//互斥访问count变量
        count--;
        if(count==0)
        {
            V(rw);//允许读者进程写
        }
        V(mutex);//释放互斥变量count
    }
}

```